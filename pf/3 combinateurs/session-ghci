GHCi, version 8.0.1: http://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/hym/c/ghci
Prelude> :l combinateurs.hs 
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex3
5
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> stupide [1..10]
[1,2,3,4,5,6,7,8,9,10]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex4
["tdpob","auie"]
*Combinateurs> ex5
["eiua","bopdt"]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex6
[[2,3,4,5,6,7,8,9,10,11],[3,5,7,9,11]]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex7
85
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex8
[True,True,True,True,True,False,False,False,False,False,False,False,False,True]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex9
False
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex10
"autie\955"
*Combinateurs> putStrLn ex10
autieλ
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex11
[0,2,4,6,8,10]
*Combinateurs> :type Ord
Ord       Ordering
*Combinateurs> :info Ord
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  {-# MINIMAL compare | (<=) #-}
  	-- Defined in ‘GHC.Classes’
instance (Ord a, Ord b) => Ord (Either a b)
  -- Defined in ‘Data.Either’
instance Ord a => Ord [a] -- Defined in ‘GHC.Classes’
instance Ord Word -- Defined in ‘GHC.Classes’
instance Ord Ordering -- Defined in ‘GHC.Classes’
instance Ord Int -- Defined in ‘GHC.Classes’
instance Ord Float -- Defined in ‘GHC.Classes’
instance Ord Double -- Defined in ‘GHC.Classes’
instance Ord Char -- Defined in ‘GHC.Classes’
instance Ord Bool -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l, Ord m) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l, m)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k, Ord l) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k, l)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j, Ord k) =>
         Ord (a, b, c, d, e, f, g, h, i, j, k)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i, Ord j) =>
         Ord (a, b, c, d, e, f, g, h, i, j)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h,
          Ord i) =>
         Ord (a, b, c, d, e, f, g, h, i)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g,
          Ord h) =>
         Ord (a, b, c, d, e, f, g, h)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) =>
         Ord (a, b, c, d, e, f, g)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) =>
         Ord (a, b, c, d, e, f)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (a, b, c, d, e)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
  -- Defined in ‘GHC.Classes’
instance (Ord a, Ord b) => Ord (a, b) -- Defined in ‘GHC.Classes’
instance Ord () -- Defined in ‘GHC.Classes’
instance Ord Integer
  -- Defined in ‘integer-gmp-1.0.0.1:GHC.Integer.Type’
instance Ord a => Ord (Maybe a) -- Defined in ‘GHC.Base’
*Combinateurs> :info Ordering 
data Ordering = LT | EQ | GT 	-- Defined in ‘GHC.Types’
instance Bounded Ordering -- Defined in ‘GHC.Enum’
instance Enum Ordering -- Defined in ‘GHC.Enum’
instance Eq Ordering -- Defined in ‘GHC.Classes’
instance Ord Ordering -- Defined in ‘GHC.Classes’
instance Read Ordering -- Defined in ‘GHC.Read’
instance Show Ordering -- Defined in ‘GHC.Show’
instance Monoid Ordering -- Defined in ‘GHC.Base’
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> :type compare
compare :: Ord a => a -> a -> Ordering
*Combinateurs> compare 1 2
LT
*Combinateurs> compare 1 1
EQ
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex12
[2,1,4,5,65,4]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex12
[1,2,4,4,5,65]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex13
[65,5,4,4,2,1]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex14
[65,5,4,4,2,1]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> ex15
[65,5,4,4,2,1]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> :type flip ex17
flip ex17 :: Bool -> Int -> Char -> [a]
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> :type generique 
generique :: (t -> t1 -> t1) -> t1 -> [t] -> t1
*Combinateurs> :type foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
*Combinateurs> :type foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> (ex18, ex19)
(65536,256)
*Combinateurs> :r 
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> :type (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
*Combinateurs> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )

combinateurs.hs:123:12: error:
    • Ambiguous type variable ‘t0’ arising from a use of ‘foldr’
      prevents the constraint ‘(Foldable t0)’ from being solved.
      Relevant bindings include
        longueur :: t0 a -> Integer (bound at combinateurs.hs:123:1)
      Probable fix: use a type annotation to specify what ‘t0’ should be.
      These potential instances exist:
        instance Foldable (Either a) -- Defined in ‘Data.Foldable’
        instance Foldable Maybe -- Defined in ‘Data.Foldable’
        instance Foldable ((,) a) -- Defined in ‘Data.Foldable’
        ...plus one other
        ...plus 24 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: foldr (\ _ r -> r + 1) 0
      In an equation for ‘longueur’: longueur = foldr (\ _ r -> r + 1) 0
Failed, modules loaded: none.
Prelude> :r
[1 of 1] Compiling Combinateurs     ( combinateurs.hs, interpreted )
Ok, modules loaded: Combinateurs.
*Combinateurs> 
Leaving GHCi.
